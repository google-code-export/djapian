#summary Tutorial for applying Djapian on example application
#labels Deprecated

== Content ==

<wiki:toc max_depth="2" />

== Introduction ==

Djapian provides simple way to apply full-text search to your exist applications and new ones. It has django-inspired style of API with flexible customizations of indexation and searching.

Let's go step-by-step through application creation process and discover Djapian basics. Before we start be sure that you have Djapian installed. If no read the complete guide to [Installation].

== Sample application ==

Assume that we what to create application that stores some information about movies and its creators. It will have some basic entities such as person(actors and directors), statuios and movies itself. Represent each of this entities with its own Django models:

{{{
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=255)

    def __unicode__(self):
        return self.name

class Studio(models.Model):
    name = models.CharField(max_length=255)

    def __unicode__(self):
        return self.name

class Movie(models.Model):
    title = models.CharField(max_length=255)
    director = models.ForeignKey(Person, related_name='director_movies')
    studio = models.ForeignKey(Studio)
    release_date = models.DateField()
    plot = models.TextField()

    cast = models.ManyToManyField(Person, related_name='cats_movies')

    def headline(self):
        return "%s - %s" % (self.author, self.title)

    def __unicode__(self):
        return self.title

}}}

And as every well crafted blog we want to add flexible search mechanism. For this purpose we will use Djapian.

== Creating indexers ==

First step is to describe how will your search indexes represent blog models. For that we have to write some classes derived from `djapian.Indexer` with index definitions and that ad it to global or our custom _index space_. It is recommended to store indexers definitions in `index.py` file of your application package directory (near `models.py`).

Prior to all we create index for `Studio` model
{{{
from models import *
from djapian import space, Indexer, CompositeIndexer

space.add_index(Studio)
}}}

`space` is the global Djapian index space. Index space - the set of Djapian indexes that stores in given file system directory. Default space stores into `DJAPIAN_DATABASE_PATH` path.

As you can see we don't provide explicit Indexer definition for `Studio` model. Because of it simplicity we can register it with default generated indexer.

For post and comments we declare custom indexers:

{{{
class PostIndexer(Indexer):
    fields = ['text']
    tags = [
        ('title', 'title'),
        ('headline', 'headline'),
    ]

space.add_index(Post, PostIndexer)

class CommentIndexer(Indexer):
   fields = ['text']
   tags = [
       ('post', 'post'),
       ('author', 'author'),

   ]

space.add_index(Comment, CommentIndexer)
}}}

To complete `Indexer` class reference read - IndexerClass.

The great feature provided by Djapian - `CompositeIndexer`. This type of indexer allows you to make search queries to multiple indexes at one and get consistent result raking. For our blog application we join all tree just created indexer for composite `blog_indexer`:

{{{
blog_indexer = CompositeIndexer(Category.indexer, Post.indexer, Comment.indexer)
}}}

== Initial data and index check ==

For the start we will add some categories:

{{{
>>> from blog.models import *
>>> Category.objects.create(name='development')
<Category: development>
>>> Category.objects.create(name='python')
<Category: python>
>>> Category.objects.create(name='xapian')
<Category: xapian>
>>> Category.objects.create(name='djapian')
<Category: djapian>
}}}

Than add number of posts (for the example posts content I've taken Wikipedia articles about Python, Django and Xapian):

{{{

}}}

And comments to them:

== Writing search view ==

And now when we make all preparations we can write our search logic. For more decoupling let's encapsulate querying of indexers into custom search form:

{{{
from django import forms
from models import *

MODEL_CHOICES = [
    ('post', Post),
    ('comment', Comment),
]

class SearchForm(forms.Form):
    query = forms.CharField(required=True)
    model = forms.ChoiceField(choices=MODEL_CHOICES, required=False)
    category = forms.ModelChoiceField(queryset=Category.objects.all(), required=False)

    def do_search(self):
        assert(self.is_valid())

        query = self.cleaned_data['query']
        model = self.cleaned_data['model']
        category = self.cleaned_data['category']

        if not model:
            indexer = blog_indexer
        else:
            indexer = model.indexer

        results = indexer.search(query).prefetch()

        if category and model in (Post, Comment):
            results = results.filter(category=category)

        return results
}}}

Our search form accepts required search query string and optionals model and category name.
If no model is specified search will be executed over all our indexer through composite `blog_indexer`. Otherwise search will be performed over concrete model indexer.

For posts and comments we also can accept category filtration and if it exists in request filter results set by given value.

{{{
def search(request):
    results = []

    if request.GET:
        form = SearchForm(request.GET)
        if form.is_valid():
            results = form.do_search()
    else:
        form = SearchForm()

    return render_to_response('search.html', {'results': results, 'form': form})

}}}

== Search results template ==

As you mentioned earlier we use `search.html` template for rendering search form and its result. It is very simple and predictable:

{{{
<div id="search_form">
    <form action='./' method='GET'>
        {{ form.as_p }}
        <p><input type="submit" value="Search!"/></p>
    </form>
</div>
<div id="results">
{% if results %}
  <h2>Search results:</h2>
  <ol>
    {% for hit in results %}
      <li>{{ hit.instance }}- {{ hit.percent }} match</li>
    {% endfor %}
  </ol>
{% endif %}
</div>
}}}

For the start we draw our search form with submit button and than if there are any results iterate over hits and print instance and percentage of match.

== Adding pagination ==

Due to Djapian's `ResultSet` object compatible with standard `Paginator` it allows you to paginate results as usual.

Let's update search view to apply page number and splitting result set into pages with 10 entries on each:

{{{
from django.core.paginator import Paginator
...
paginator = Paginator(form.do_search(), 10)
results = paginator.page(request.GET.get('page', 1))
}}}

And we have to update template as well:

{{{
...
<ol start={{ results.start_index }}>
   {% for hit in results.object_list %}
       <li>{{ hit.instance }}- {{ hit.percent }} match</li>
   {% endfor %}
</ol>
{% if results.has_next }}
<a href="./?query={{ form.cleaned_data.query }}&page={{ results.next_page }}">Next page</a>
{% endif %}
}}}

== Starting index daemon ==

== Conclusion ==
