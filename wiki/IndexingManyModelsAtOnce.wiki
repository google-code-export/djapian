#summary How to index data from many models at once.

= Introduction =

Suppose you have two models you need to index, Movie and Playlist, and would like to create a unique index for both models. Here's how to do it.

= The code =

== {{{SearchIndexData}}} ==
First, create a {{{SearchIndexData}}} class in your application's models.py file. This class will be used as a proxy for the models you want to index.

{{{
from django.db import models
from django.contrib.contenttypes.models import ContentType

class SearchIndexData(models.Model):
    """ This model holds a reference on all searchable items in
        the database and is used for the integration with Djapian. """
    # This class is a generic relation as described at
    # http://www.djangoproject.com/documentation/0.96/models/generic_relations/
    content_type = models.ForeignKey(ContentType)
    object_id = models.PositiveIntegerField()
    content_object = models.GenericForeignKey()
    
    # Integration with Djapian, an API to access the Xapian
    # search engine with Django.
    # http://code.google.com/p/djapian/
    
    DJANGO_PROJECT_NAME = 'your_project'
    DJANGO_APPLICATION_NAME = 'your_appl'

    index_model = "%s.%s.models.search_index" % (DJANGO_PROJECT_NAME, DJANGO_APPLICATION_NAME)

    class Meta:
        unique_together = (("content_type", "object_id"),)
    
    # Not editable via the administration interface.
    #class Admin :
    #    pass
    
    # Utilities
    def _object_is_a(self, obj_model):
        return self.content_type.app_label == self.DJANGO_APPLICATION_NAME and self.content_type.model == obj_model
    
    def _object_is_in(self, obj_model_list):
        return self.content_type.app_label == self.DJANGO_APPLICATION_NAME and self.content_type.model in obj_model_list
    
    # Properties
    # We use the content type framework (http://www.djangoproject.com/documentation/contenttypes/)
    # The "content_object" is an instance of a particular model (for example Movie or Playlist)

    @property
    def title(self):
        # Both Movie and Playlist models have the title attribute
        if self._object_is_in(("movie", "playlist")):
            return self.content_object.title
        return None
    
    @property
    def description(self):
        # Both Movie and Playlist models have the title attribute
        if self._object_is_in(("movie", "playlist")):
            return self.content_object.description
        return None

    @property
    def director(self):
        # Only the Movie model has the get_director() attribute; calling this function
        # for a Playlist instance will return None (and Djapian won't index the value)
        if self._object_is_a("movie"):
            return self.content_object.get_director()
        return None
}}}

== {{{search_index}}} instance of {{{XapianIndexer}}} ==

Then, we need to create a {{{search_index}}} instance of the {{{XapianIndexer}}} class, so we can tell Djapian where to locate the database on the hard drive, what model to index, and what fields of the model to index.

{{{
from djapian.backend.backends import XapianIndexer
from django.conf import settings

search_index = XapianIndexer(
    # Path where the index database is
    # For this to work add a line similar to this in your settings.py file :
    # XAPIAN_INDEX_DIRECTORY = "/var/myproject/xapian_index"
    settings.XAPIAN_INDEX_DIRECTORY,
    
    # Model to index
    SearchIndexData,
    
    # Fields to index without a prefix
    # We can limit the number of characters indexed with the following syntax :
    # ('SearchIndexData.title', 20) instead of 'SearchIndexData.title'
    ['SearchIndexData.title', 'SearchIndexData.description', 'SearchIndexData.director'],
    
    # Attributes with prefix, to search like Google "title:Foobar"
    {
        'title':'SearchIndexData.title',
        'desc':'SearchIndexData.description',
        'director':'SearchIndexData.director',
    }
)
}}}

== Saving the models into {{{SearchIndexData}}} ==

We then need to modify the save() methods of the Movie and Playlist classes so that a {{{SearchIndexData}}} instance can be created each time our objects are modified. 

{{{
def save_model_into_search_index(model_instance):
    """ save a model instance into the SearchIndexData """
    ctype = ContentType.objects.get_for_model(model_instance)
    (search_index_data, was_created) = SearchIndexData.objects.get_or_create(\
        content_type=ctype, object_id=model_instance.id, \
        defaults={'content_object':model_instance})
    # We must make sure to save the object in order to trigger 
    # the update of the index
    if not was_created:
        search_index_data.save()
}}}

{{{
class Movie:
   # ...
   def save(self):
       super(Movie,self).save()
       save_model_into_search_index(self)
}}}

{{{
class Playlist:
   # ...
   def save(self):
       super(Playlist,self).save()
       save_model_into_search_index(self)
}}}

== Deleting the models from {{{SearchIndexData}}} ==

The same thing must be done for the case where the different models to index are deleted :

{{{
def delete_model_from_search_index(model_instance):
    """ delete a model instance from the SearchIndexData """
    ctype = ContentType.objects.get_for_model(model_instance)
    try:
        search_index_data = SearchIndexData.objects.get(\
            content_type=ctype, object_id=model_instance.id)
        search_index_data.delete()
    except SearchIndexData.DoesNotExist:
        pass
}}}

{{{
class Movie:
   # ...
   def delete(self):
        delete_model_from_search_index(self)
        super(Movie,self).delete()
}}}

{{{
class Playlist:
   # ...
   def delete(self):
        delete_model_from_search_index(self)
        super(Playlist,self).delete()
}}}

= How will Djapian know that a new {{{SearchIndexData}}} was created or deleted? =
This is thanks to the {{{XapianIndexer}}} instance we create in our model. The constructor of {{{XapianIndexer}}} connects the {{{post_save}}} and {{{pre_delete}}} signals to the methods defined in signals.py; these methods update the Change model of Djapian with a reference to the model that was saved or deleted.

Then, run_djapian.py will detect a new entry in the Change database, and will update Xapian's index accordingly.